{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_0-f559c7bf237ef33043fb36286d19d75c6681d876",
  "solcVersion": "0.8.0",
  "solcLongVersion": "0.8.0+commit.c7dfd78e",
  "userSourceNameMap": {
    "contracts/Exchange.sol": "project/contracts/Exchange.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "istanbul",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": ["ast"],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/Exchange.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport './RichardToken.sol';\r\n\r\ncontract Exchange {\r\n  // 收费账户地址\r\n  address public immutable feeAccount;\r\n  // 收费比例 (基点，10000 = 100%)\r\n  uint256 public immutable feePercentage;\r\n\r\n  // ETH 地址常量\r\n  address public constant ETHER = address(0);\r\n\r\n  // 用户代币余额映射 [代币地址][用户地址] => 余额\r\n  mapping(address => mapping(address => uint256)) public tokens;\r\n\r\n  // 订单结构体 - 优化存储布局\r\n  struct Order {\r\n    uint256 id; // 订单ID\r\n    address user; // 订单创建者\r\n    address tokenGet; // 要获得的代币\r\n    uint256 tokenGetAmount; // 要获得的代币数量\r\n    address tokenGive; // 要给出的代币\r\n    uint256 tokenGiveAmount; // 要给出的代币数量\r\n    uint256 timestamp; // 创建时间\r\n    bool filled; // 是否已成交\r\n    bool cancelled; // 是否已取消\r\n  }\r\n\r\n  // 订单映射（使用哈希作为键）\r\n  mapping(bytes32 => Order) public orders;\r\n\r\n  // 重入攻击保护\r\n  bool private locked;\r\n\r\n  constructor(address _feeAccount, uint256 _feePercentage) {\r\n    require(_feeAccount != address(0), 'Invalid fee account');\r\n    // 这里为什么是10000？\r\n    // 10000bp = 100%, 100bp = 1%\r\n    require(_feePercentage <= 10000, 'Fee percentage too high'); // 最大 100%\r\n    feeAccount = _feeAccount;\r\n    feePercentage = _feePercentage;\r\n  }\r\n\r\n  // 重入攻击保护修饰符\r\n  modifier nonReentrant() {\r\n    require(!locked, 'Reentrant call');\r\n    locked = true;\r\n    _;\r\n    locked = false;\r\n  }\r\n\r\n  // 生成订单哈希 - 使用多个随机因子，无需 nonce\r\n  function generateOrderHash(\r\n    address _user,\r\n    address _tokenGet,\r\n    uint256 _tokenGetAmount,\r\n    address _tokenGive,\r\n    uint256 _tokenGiveAmount\r\n  ) private view returns (bytes32) {\r\n    return\r\n      keccak256(\r\n        abi.encodePacked(\r\n          _user,\r\n          _tokenGet,\r\n          _tokenGetAmount,\r\n          _tokenGive,\r\n          _tokenGiveAmount,\r\n          block.timestamp,\r\n          block.difficulty,\r\n          block.coinbase,\r\n          block.number,\r\n          msg.sender,\r\n          address(this)\r\n        )\r\n      );\r\n  }\r\n\r\n  // 事件定义 - 优化 gas\r\n  event Deposit(\r\n    address indexed token,\r\n    address indexed user,\r\n    uint256 amount,\r\n    uint256 balance\r\n  );\r\n  event Withdraw(\r\n    address indexed token,\r\n    address indexed user,\r\n    uint256 amount,\r\n    uint256 balance\r\n  );\r\n  event OrderCreated(\r\n    bytes32 indexed orderHash,\r\n    address indexed user,\r\n    address tokenGet,\r\n    uint256 tokenGetAmount,\r\n    address tokenGive,\r\n    uint256 tokenGiveAmount,\r\n    uint256 timestamp\r\n  );\r\n  event OrderCancelled(\r\n    bytes32 indexed orderHash,\r\n    address indexed user,\r\n    uint256 timestamp\r\n  );\r\n  event OrderFilled(\r\n    bytes32 indexed orderHash,\r\n    address indexed user,\r\n    address indexed filler,\r\n    uint256 amount,\r\n    uint256 timestamp\r\n  );\r\n\r\n  // ETH 存款 - 添加重入保护\r\n  function depositEther() public payable nonReentrant {\r\n    require(msg.value > 0, 'Amount must be greater than 0');\r\n    tokens[ETHER][msg.sender] = tokens[ETHER][msg.sender] + msg.value;\r\n    emit Deposit(ETHER, msg.sender, msg.value, tokens[ETHER][msg.sender]);\r\n  }\r\n\r\n  // 代币存款 - 优化 gas 和安全性\r\n  function depositToken(address _token, uint256 _amount) public nonReentrant {\r\n    require(_token != ETHER, 'Use depositEther for ETH');\r\n    require(_token != address(0), 'Invalid token address');\r\n    require(_amount > 0, 'Amount must be greater than 0');\r\n\r\n    // 先更新余额，再转账（防止重入攻击） CEI模式\r\n    tokens[_token][msg.sender] = tokens[_token][msg.sender] + _amount;\r\n\r\n    // 执行转账\r\n    require(\r\n      RichardToken(_token).transferFrom(msg.sender, address(this), _amount),\r\n      'Transfer failed'\r\n    );\r\n\r\n    emit Deposit(_token, msg.sender, _amount, tokens[_token][msg.sender]);\r\n  }\r\n\r\n  // ETH 提取 - 优化安全性\r\n  function withdrawEther(uint256 _amount) public nonReentrant {\r\n    require(_amount > 0, 'Amount must be greater than 0');\r\n    require(tokens[ETHER][msg.sender] >= _amount, 'Insufficient balance');\r\n\r\n    // 先更新余额\r\n    tokens[ETHER][msg.sender] = tokens[ETHER][msg.sender] - _amount;\r\n\r\n    // 使用 call 而不是 transfer，避免 gas 限制问题\r\n    (bool success, ) = payable(msg.sender).call{ value: _amount }('');\r\n    require(success, 'ETH transfer failed');\r\n\r\n    emit Withdraw(ETHER, msg.sender, _amount, tokens[ETHER][msg.sender]);\r\n  }\r\n\r\n  // 代币提取 - 优化安全性\r\n  function withdrawToken(address _token, uint256 _amount) public nonReentrant {\r\n    require(_token != ETHER, 'Use withdrawEther for ETH');\r\n    require(_token != address(0), 'Invalid token address');\r\n    require(_amount > 0, 'Amount must be greater than 0');\r\n    require(tokens[_token][msg.sender] >= _amount, 'Insufficient balance');\r\n\r\n    // 先更新余额\r\n    tokens[_token][msg.sender] = tokens[_token][msg.sender] - _amount;\r\n\r\n    // 执行转账\r\n    require(\r\n      RichardToken(_token).transfer(msg.sender, _amount),\r\n      'Transfer failed'\r\n    );\r\n\r\n    emit Withdraw(_token, msg.sender, _amount, tokens[_token][msg.sender]);\r\n  }\r\n\r\n  // 查询余额 - 优化 gas\r\n  function balanceOf(\r\n    address _token,\r\n    address _user\r\n  ) public view returns (uint256) {\r\n    return tokens[_token][_user];\r\n  }\r\n\r\n  // 创建订单 - 使用纯哈希 ID 系统： 创建者(exchange 本身)\r\n  function makeOrder(\r\n    address _tokenGet,\r\n    uint256 _tokenGetAmount,\r\n    address _tokenGive,\r\n    uint256 _tokenGiveAmount\r\n  ) public {\r\n    require(_tokenGet != address(0), 'Invalid tokenGet address');\r\n    require(_tokenGive != address(0), 'Invalid tokenGive address');\r\n    require(_tokenGetAmount > 0, 'TokenGet amount must be greater than 0');\r\n    require(_tokenGiveAmount > 0, 'TokenGive amount must be greater than 0');\r\n    require(_tokenGet != _tokenGive, 'Cannot trade same token');\r\n\r\n    // 检查用户是否有足够的代币来创建订单\r\n    require(\r\n      tokens[_tokenGive][msg.sender] >= _tokenGiveAmount,\r\n      'Insufficient balance for order'\r\n    );\r\n\r\n    // 生成唯一的订单哈希\r\n    bytes32 orderHash = generateOrderHash(\r\n      msg.sender,\r\n      _tokenGet,\r\n      _tokenGetAmount,\r\n      _tokenGive,\r\n      _tokenGiveAmount\r\n    );\r\n\r\n    // 检查哈希是否已存在（极低概率）\r\n    require(orders[orderHash].user == address(0), 'Order hash collision');\r\n\r\n    // 创建订单\r\n    Order memory newOrder = Order({\r\n      id: 0, // 不再使用数字 ID\r\n      user: msg.sender,\r\n      tokenGet: _tokenGet,\r\n      tokenGetAmount: _tokenGetAmount,\r\n      tokenGive: _tokenGive,\r\n      tokenGiveAmount: _tokenGiveAmount,\r\n      timestamp: block.timestamp,\r\n      filled: false,\r\n      cancelled: false\r\n    });\r\n\r\n    // 存储订单\r\n    orders[orderHash] = newOrder;\r\n\r\n    emit OrderCreated(\r\n      orderHash,\r\n      msg.sender,\r\n      _tokenGet,\r\n      _tokenGetAmount,\r\n      _tokenGive,\r\n      _tokenGiveAmount,\r\n      block.timestamp\r\n    );\r\n  }\r\n\r\n  // 取消订单 - 使用哈希 ID\r\n  function cancelOrder(bytes32 _orderHash) public {\r\n    require(orders[_orderHash].user != address(0), 'Order not found');\r\n    Order storage order = orders[_orderHash];\r\n    require(order.user == msg.sender, 'Not order owner');\r\n    require(!order.filled, 'Order already filled');\r\n    require(!order.cancelled, 'Order already cancelled');\r\n\r\n    order.cancelled = true;\r\n    emit OrderCancelled(_orderHash, msg.sender, block.timestamp);\r\n  }\r\n\r\n  // 成交订单 - 使用哈希 ID\r\n  function fillOrder(bytes32 _orderHash) public nonReentrant {\r\n    require(orders[_orderHash].user != address(0), 'Order not found');\r\n    require(\r\n      orders[_orderHash].tokenGiveAmount > 0,\r\n      'Order tokenGiveAmount is 0'\r\n    );\r\n\r\n    Order storage order = orders[_orderHash];\r\n    require(!order.filled, 'Order already filled');\r\n    require(!order.cancelled, 'Order cancelled');\r\n    require(order.user != msg.sender, 'Cannot fill own order');\r\n\r\n    // 计算手续费\r\n    uint256 feeAmount = (order.tokenGetAmount * feePercentage) / 10000;\r\n\r\n    // 流动池子是否有足够的代币\r\n    require(\r\n      tokens[order.tokenGive][order.user] >= order.tokenGiveAmount,\r\n      'Order owner insufficient balance'\r\n    );\r\n    require(\r\n      tokens[order.tokenGet][msg.sender] >= order.tokenGetAmount + feeAmount,\r\n      'Filler insufficient balance'\r\n    );\r\n\r\n    // 计算成交比例: 1 RTK: 100ETH 关系， 固定关系,后期左流动池子，动态换算\r\n    // 手续费账户增加\r\n    tokens[order.tokenGet][feeAccount] =\r\n      tokens[order.tokenGet][feeAccount] +\r\n      feeAmount;\r\n    // 发起者减少\r\n    // tokens[order.tokenGet][msg.sender] = tokens[order.tokenGet][msg.sender].sub(feeAmount);\r\n\r\n    // 执行交易： order是以发起者为对象\r\n    // 先更新余额，再转账（防止重入攻击）\r\n    // get是获取的币，give是减少的币\r\n    // 创建者的币，tokenget币应该是增加\r\n    tokens[order.tokenGet][order.user] =\r\n      tokens[order.tokenGet][order.user] +\r\n      order.tokenGetAmount;\r\n    // 发起者是币，tokenGet币应该是减少\r\n    tokens[order.tokenGet][msg.sender] =\r\n      tokens[order.tokenGet][msg.sender] -\r\n      (order.tokenGetAmount + feeAmount);\r\n    // 币币交换\r\n    tokens[order.tokenGive][order.user] =\r\n      tokens[order.tokenGive][order.user] -\r\n      order.tokenGiveAmount;\r\n    // 发起者是币，tokenGive币应该是减少\r\n    tokens[order.tokenGive][msg.sender] =\r\n      tokens[order.tokenGive][msg.sender] +\r\n      order.tokenGiveAmount;\r\n    // 更新订单状态\r\n    order.filled = true;\r\n    emit OrderFilled(\r\n      _orderHash,\r\n      order.user,\r\n      msg.sender,\r\n      order.tokenGetAmount,\r\n      block.timestamp\r\n    );\r\n  }\r\n\r\n  // 获取订单信息（通过哈希）\r\n  function getOrder(\r\n    bytes32 _orderHash\r\n  )\r\n    public\r\n    view\r\n    returns (\r\n      uint256 id,\r\n      address user,\r\n      address tokenGet,\r\n      uint256 tokenGetAmount,\r\n      address tokenGive,\r\n      uint256 tokenGiveAmount,\r\n      uint256 timestamp,\r\n      bool filled,\r\n      bool cancelled\r\n    )\r\n  {\r\n    require(orders[_orderHash].user != address(0), 'Order not found');\r\n    Order storage order = orders[_orderHash];\r\n    return (\r\n      order.id,\r\n      order.user,\r\n      order.tokenGet,\r\n      order.tokenGetAmount,\r\n      order.tokenGive,\r\n      order.tokenGiveAmount,\r\n      order.timestamp,\r\n      order.filled,\r\n      order.cancelled\r\n    );\r\n  }\r\n\r\n  // 检查订单是否存在\r\n  function orderExists(bytes32 _orderHash) public view returns (bool) {\r\n    return orders[_orderHash].user != address(0);\r\n  }\r\n}\r\n"
      },
      "project/contracts/RichardToken.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title RichardToken\r\n * @dev ERC20标准 代币合约实现\r\n * @notice 这是一个优化的 ERC20 代币合约，具有更高的安全性和 gas 效率\r\n */\r\ncontract RichardToken {\r\n    \r\n    // 代币基本信息 - 使用 constant 优化 gas\r\n    string public constant NAME = \"RichardToken\";\r\n    string public constant SYMBOL = \"RTK\";\r\n    uint8 public constant DECIMALS = 18;\r\n    \r\n    // 总供应量 - 使用 immutable 优化 gas\r\n    uint256 public immutable totalSupply;\r\n\r\n    // 余额映射\r\n    mapping(address => uint256) public balanceOf;\r\n    \r\n    // 授权映射\r\n    mapping(address => mapping(address => uint256)) public allowance;\r\n    \r\n    // 重入攻击保护\r\n    bool private locked;\r\n    \r\n    // 事件定义 - 优化 gas\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    // 构造函数 - 优化 gas 和安全性\r\n    constructor() {\r\n        // 这个是一个科学计数法\r\n        uint256 initialSupply = 10000 * 10 ** DECIMALS;\r\n        totalSupply = initialSupply;\r\n        balanceOf[msg.sender] = initialSupply;\r\n        emit Transfer(address(0), msg.sender, initialSupply);\r\n    }\r\n    \r\n    // 重入攻击保护修饰符\r\n    modifier nonReentrant() {\r\n        require(!locked, \"Reentrant call\");\r\n        locked = true;\r\n        _;\r\n        locked = false;\r\n    }\r\n    /*\r\n        checks-effects-interactions原则\r\n        先检查-再修改-再执行，添加锁=>实现原子化\r\n    */\r\n    // 转账函数 - 优化 gas 和安全性\r\n    function transfer(address to, uint256 value) public nonReentrant returns (bool success) {\r\n        require(to != address(0), \"Transfer to zero address\");\r\n        require(value > 0, \"Transfer amount must be greater than 0\");\r\n        return _transfer(msg.sender, to, value);\r\n    }\r\n\r\n     // 授权函数 - 优化 gas 和安全性\r\n    function approve(address spender, uint256 value) public returns (bool success) {\r\n        require(spender != address(0), \"Approve to zero address\");\r\n        require(spender != msg.sender, \"Approve to self\");\r\n        // msg.sender：发起者地址， spender： 授权方地址 { \"发起者\": { 授权方: \"额度\" } }\r\n        // 这里的msg.sender是发起者？还是部署者？还是拥有者？合约地址？关系是什么？\r\n        allowance[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n    \r\n    // 授权转账函数 - 优化 gas 和安全性\r\n    function transferFrom(address from, address to, uint256 value) public nonReentrant returns (bool success) {\r\n        require(from != address(0), \"Transfer from zero address\");\r\n        require(to != address(0), \"Transfer to zero address\");\r\n        require(value > 0, \"Transfer amount must be greater than 0\");\r\n        require(balanceOf[from] >= value, \"Insufficient balance\");\r\n        require(allowance[from][msg.sender] >= value, \"Insufficient allowance\");\r\n        \r\n        // 先更新授权额度，再执行转账（CEI 模式）\r\n        allowance[from][msg.sender] = allowance[from][msg.sender] - value;\r\n        return _transfer(from, to, value);\r\n    }\r\n    \r\n    // 增加授权额度 - ERC20 标准扩展\r\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool success) {\r\n        require(spender != address(0), \"Approve to zero address\");\r\n        require(spender != msg.sender, \"Approve to self\");\r\n        \r\n        uint256 newAllowance = allowance[msg.sender][spender] + addedValue;\r\n        allowance[msg.sender][spender] = newAllowance;\r\n        emit Approval(msg.sender, spender, newAllowance);\r\n        return true;\r\n    }\r\n    \r\n    // 减少授权额度 - ERC20 标准扩展\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool success) {\r\n        require(spender != address(0), \"Approve to zero address\");\r\n        require(allowance[msg.sender][spender] >= subtractedValue, \"Decreased allowance below zero\");\r\n        \r\n        uint256 newAllowance = allowance[msg.sender][spender] - subtractedValue;\r\n        allowance[msg.sender][spender] = newAllowance;\r\n        emit Approval(msg.sender, spender, newAllowance);\r\n        return true;\r\n    }\r\n    // 内部转账函数 - 优化 gas 和安全性\r\n    function _transfer(address from, address to, uint256 value) internal returns (bool success) {\r\n        require(balanceOf[from] >= value, \"Insufficient balance\");\r\n        \r\n        balanceOf[from] = balanceOf[from] - value;\r\n        balanceOf[to] = balanceOf[to] + value;\r\n        \r\n        // 触发转账事件\r\n        emit Transfer(from, to, value);\r\n        return true;\r\n    }\r\n    \r\n    // 查询余额 - 优化 gas\r\n    function getBalance(address account) public view returns (uint256) {\r\n        return balanceOf[account];\r\n    }\r\n    \r\n    // 查询授权额度 - 优化 gas\r\n    function getAllowance(address owner, address spender) public view returns (uint256) {\r\n        return allowance[owner][spender];\r\n    }\r\n    \r\n    // 查询总供应量 - 优化 gas\r\n    function getTotalSupply() public view returns (uint256) {\r\n        return totalSupply;\r\n    }\r\n}\r\n\r\n// web3开发，一定要考虑边界问题！！！"
      }
    }
  }
}
